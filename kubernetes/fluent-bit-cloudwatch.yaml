# ============================================================================
# fluent-bit-cloudwatch.yaml (DEDUP via rewrite_tag + selective OUTPUT Match)
#
# 목적
# - EKS 노드의 컨테이너 로그(/var/log/containers/*.log)를 Fluent Bit이 tail로 수집
# - Kubernetes 메타데이터(네임스페이스/파드/컨테이너 등)를 붙여 CloudWatch Logs로 전송
#
# 중복 제거(핵심 설계)
# - tail INPUT의 Tag는 kube.* (원본 레코드)
# - lua filter로 stream_name = "<pod>/<container>" 필드 생성
# - rewrite_tag filter로 stream_name 값을 "새 태그"로 사용해 레코드를 추가 emit
#   - Rule ... true  => 원본 kube.* 레코드는 유지 + 새 태그 레코드도 추가 생성
# - CloudWatch OUTPUT은 Match "*/*" 로만 받게 제한
#   => 결과적으로 CloudWatch로는 "<pod>/<container>" 태그로 emit된 레코드만 들어가고,
#      kube.* 원본 레코드는 OUTPUT 매칭에서 제외되어 중복 전송이 제거됨
#
# CloudWatch 네이밍 정책
# - Log Group: /eks/<env>/<namespace>
# - Log Stream: from-fluent-bit-<pod>/<container>
#
# 운영 시 주의
# - rewrite_tag의 Emitter_Storage.type=memory 는 재시작 시 버퍼가 유지되지 않음
#   (정확히 한 번 전송(exactly-once)이 필요한 환경이면 filesystem 기반 버퍼 검토 필요)
# - log_group_template 사용을 위해 kubernetes filter가 namespace_name을 채워줘야 함
# - /var/log 마운트는 노드 파일시스템 접근이므로 DaemonSet + hostPath가 전제
# ============================================================================

apiVersion: v1
kind: Namespace
metadata:
  # Fluent Bit 리소스를 앱 네임스페이스와 분리하여 관측성(Observability) 계층을 독립 운영
  name: amazon-cloudwatch
  labels:
    app.kubernetes.io/name: fluent-bit
    app.kubernetes.io/part-of: observability

---
apiVersion: v1
kind: ServiceAccount
metadata:
  # IRSA를 사용하기 위한 ServiceAccount
  # - 이 SA를 사용하는 Pod는 annotation의 IAM Role을 Assume하여 CloudWatch Logs에 접근
  name: fluent-bit
  namespace: amazon-cloudwatch
  annotations:
    eks.amazonaws.com/role-arn: arn:aws:iam::235704034905:role/eks-fluent-bit-cloudwatch-role
  labels:
    app.kubernetes.io/name: fluent-bit
    app.kubernetes.io/part-of: observability

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  # kubernetes filter가 파드/네임스페이스 메타데이터를 조회할 수 있도록 읽기 권한 부여
  name: fluent-bit-read-k8s-meta
  labels:
    app.kubernetes.io/name: fluent-bit
    app.kubernetes.io/part-of: observability
rules:
  - apiGroups: [""]
    resources:
      # kubernetes filter가 pod_name/container_name/namespace_name 등을 붙이기 위해 조회
      - pods
      - namespaces
    verbs: ["get", "list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  # 위 ClusterRole을 ServiceAccount(fluent-bit)에 바인딩
  name: fluent-bit-read-k8s-meta-binding
  labels:
    app.kubernetes.io/name: fluent-bit
    app.kubernetes.io/part-of: observability
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: fluent-bit-read-k8s-meta
subjects:
  - kind: ServiceAccount
    name: fluent-bit
    namespace: amazon-cloudwatch

---
apiVersion: v1
kind: ConfigMap
metadata:
  # Fluent Bit 메인 설정 + 파서 + Lua 스크립트를 단일 ConfigMap에 패킹
  # - DaemonSet에서 /fluent-bit/etc 로 마운트하여 설정 파일로 사용
  # - Lua 스크립트는 별도 경로(/fluent-bit/scripts)로 마운트
  name: fluent-bit-config
  namespace: amazon-cloudwatch
  labels:
    app.kubernetes.io/name: fluent-bit
    app.kubernetes.io/part-of: observability
data:

  fluent-bit.conf: |
    [SERVICE]
        # Flush 간격(초): 버퍼에 쌓인 레코드를 OUTPUT으로 내보내는 주기
        Flush                 1

        # Fluent Bit 자체 로그 레벨
        Log_Level             info

        # 파서 파일 로딩
        Parsers_File          parsers.conf

        # 내장 HTTP 서버(메트릭/헬스 확인용)
        HTTP_Server           On
        HTTP_Listen           0.0.0.0
        HTTP_Port             2020

    [INPUT]
        # 노드의 컨테이너 로그 파일을 tail 방식으로 수집
        Name                  tail

        # Kubernetes가 생성하는 컨테이너 로그 심볼릭 링크들이 모이는 경로
        Path                  /var/log/containers/*.log

        # 수집 레코드의 "초기 태그"
        # - 이후 FILTER/OUTPUT의 Match 조건으로 라우팅하는 핵심 키
        Tag                   kube.*

        # 신규 파일/파일 목록 재스캔 주기(초)
        Refresh_Interval      5

        # 로그 로테이션 이후 핸들 유지/대기(초)
        # - 너무 짧으면 로테이션 직후 유실 가능성, 너무 길면 파일 핸들 증가 가능성
        Rotate_Wait           30

        # 입력 버퍼 상한
        # - OUTPUT이 막히면 여기까지 쌓이고, 초과 시 드롭/백프레셔 상황이 발생할 수 있음
        Mem_Buf_Limit         50MB

        # 한 줄이 지나치게 긴 경우 드롭(메모리 폭주 방지)
        Skip_Long_Lines       On

        # tail 오프셋 저장 DB(재시작 시 중복 전송/유실을 줄이기 위함)
        DB                    /var/fluent-bit/state/flb_kube.db

        # 오프셋 DB sync 정책(성능/내구성 트레이드오프)
        DB.Sync               Normal

        # 컨테이너 런타임(CRI) 로그 라인을 파싱하기 위한 parser 지정
        Parser                cri

    [FILTER]
        # kube.* 태그 레코드에 Kubernetes 메타데이터를 부착
        # - record["kubernetes"] 아래에 namespace_name/pod_name/container_name 등 생성
        Name                  kubernetes
        Match                 kube.*

        # tail input에서 Tag가 kube.var.log.containers.<...> 형태일 때 접두사 제거에 사용
        # - 여기서는 Tag가 kube.* 로 들어오므로, 쿠버네티스 플러그인 내부 파싱에 참고값
        Kube_Tag_Prefix       kube.var.log.containers.

        # 컨테이너 로그 JSON/문자열을 최상위로 합치는 기능
        # - Merge_Log On  => 원본 "log" 내용을 병합 처리
        # - Merge_Log_Key => 병합된 로그를 넣을 키 이름
        Merge_Log             On
        Merge_Log_Key         log

        # 병합 후 원본 log 필드 유지 여부
        # - Off면 원본을 제거해 페이로드를 줄이는 효과
        Keep_Log              Off

        # Kubernetes 로깅 표준(예: JSON) 파싱을 활성화
        K8S-Logging.Parser    On
        K8S-Logging.Exclude   Off

    [FILTER]
        # stream_name="<pod>/<container>" 필드를 생성
        # - 이후 rewrite_tag가 이 필드를 태그로 사용해 라우팅 키를 만들어냄
        Name                  lua
        Match                 kube.*
        script                /fluent-bit/scripts/stream_name.lua
        call                  set_stream_name

    [FILTER]
        # rewrite_tag: 기존 레코드를 "새 태그"로 재발행(emit)하여 라우팅을 분기
        #
        # Rule 문법:
        # - Rule <key> <regex> <new_tag> <keep>
        #
        # 여기서:
        # - key     : $stream_name (lua가 만든 필드)
        # - regex   : ^(.+)$       (비어있지 않은 값이면 매치)
        # - new_tag : $1           (매치 그룹 전체 = "<pod>/<container>")
        # - keep    : true         (원본 kube.* 레코드도 유지)
        #
        # 결과:
        # - kube.* 원본 레코드는 계속 파이프라인에 남아있지만
        # - "<pod>/<container>" 태그의 "복제 레코드"가 추가로 발생
        # - OUTPUT을 "*/*"로 제한하면 복제 레코드만 CloudWatch로 가게 됨
        Name                  rewrite_tag
        Match                 kube.*
        Rule                  $stream_name ^(.+)$ $1 true

        # rewrite_tag가 레코드를 내보낼 내부 emitter 이름
        Emitter_Name          stream_emitter

        # emitter 버퍼 저장소
        # - memory: 빠르지만 재시작 시 유실 가능
        # - filesystem: 디스크 기반으로 내구성을 높이지만 I/O 비용 증가
        Emitter_Storage.type  memory

    [OUTPUT]
        # CloudWatch Logs로 전송하는 플러그인
        Name                  cloudwatch_logs

        # 중복 제거의 핵심:
        # - "<pod>/<container>" 형태 태그만 매칭
        # - kube.* 원본은 매칭되지 않으므로 CloudWatch로 가지 않음
        Match                 */*

        # CloudWatch 리전
        region                ap-northeast-2

        # 로그 그룹이 없으면 자동 생성
        auto_create_group     true

        # 로그 보존 기간(일)
        log_retention_days    7

        # 기본 로그 그룹(템플릿이 적용되지 않을 경우 fallback)
        # - 템플릿이 정상 적용되면 아래 template 값이 우선 사용됨
        log_group_name        /eks/${ENV_NAME}/unknown

        # 레코드에 붙은 kubernetes 메타데이터를 사용해 그룹명을 동적으로 구성
        # - /eks/<env>/<namespace>
        log_group_template    /eks/${ENV_NAME}/$kubernetes['namespace_name']

        # 로그 스트림 이름 prefix
        # - 실제 스트림명은 prefix + (태그 혹은 내부 규칙에 따라) 뒤가 붙어 구성됨
        # - 여기서는 태그가 "<pod>/<container>" 형태로 들어오므로
        #   "from-fluent-bit-<pod>/<container>" 패턴을 기대
        log_stream_prefix     from-fluent-bit-

  parsers.conf: |
    [PARSER]
        # CRI(Container Runtime Interface) 로그 포맷 파서
        # 예: 2026-01-02T... stdout F <log>
        Name        cri
        Format      regex

        # time / stdout|stderr / tag / 실제 로그 본문(log)로 분해
        Regex       ^(?<time>[^ ]+) (?<stream>stdout|stderr) (?<logtag>[^ ]*) (?<log>.*)$

        # Fluent Bit의 time 필드로 사용할 키
        Time_Key    time

        # CRI 타임스탬프 포맷
        Time_Format %Y-%m-%dT%H:%M:%S.%L%z

  stream_name.lua: |
    -- set_stream_name:
    -- - kubernetes filter가 붙여준 record["kubernetes"]에서 pod_name/container_name을 읽음
    -- - stream_name="<pod>/<container>" 생성
    -- - rewrite_tag가 $stream_name 값을 new tag로 사용하여 레코드를 재발행할 수 있게 됨
    function set_stream_name(tag, ts, record)
      local k8s = record["kubernetes"]
      if k8s == nil then
        -- kubernetes 메타데이터가 없으면 그대로 통과
        return 1, ts, record
      end

      local pod = k8s["pod_name"]
      local container = k8s["container_name"]

      if pod ~= nil and container ~= nil then
        record["stream_name"] = pod .. "/" .. container
      end

      return 1, ts, record
    end

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  # 각 노드에 Fluent Bit Pod 1개씩 배치(노드 레벨 로그 수집기)
  name: fluent-bit
  namespace: amazon-cloudwatch
  labels:
    app.kubernetes.io/name: fluent-bit
    app.kubernetes.io/part-of: observability
spec:
  # DaemonSet이 관리할 Pod 셀렉터
  selector:
    matchLabels:
      app.kubernetes.io/name: fluent-bit

  template:
    metadata:
      # selector.matchLabels 와 반드시 일치해야 함
      labels:
        app.kubernetes.io/name: fluent-bit
        app.kubernetes.io/part-of: observability

    spec:
      # IRSA + RBAC가 연결된 ServiceAccount 사용
      serviceAccountName: fluent-bit

      # SIGTERM 이후 graceful shutdown을 위한 유예 시간
      # - tail 오프셋 DB flush 및 남은 버퍼 출력에 도움
      terminationGracePeriodSeconds: 30

      containers:
        - name: fluent-bit

          # AWS Observability 배포 이미지(Fluent Bit + 플러그인 포함)
          image: public.ecr.aws/aws-observability/aws-for-fluent-bit:3.1.1
          imagePullPolicy: IfNotPresent

          env:
            # log_group_template 등에 사용되는 환경 이름
            - name: ENV_NAME
              value: "prod"

          ports:
            # [SERVICE] HTTP_Server가 사용하는 포트(메트릭/헬스 확인)
            - name: http
              containerPort: 2020

          resources:
            # 요청/제한 리소스는 클러스터 규모와 로그량에 맞게 튜닝 필요
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 512Mi

          volumeMounts:
            # 노드의 /var/log 를 읽어서 컨테이너 로그 파일에 접근
            - name: varlog
              mountPath: /var/log
              readOnly: true

            # tail 오프셋 DB 저장 경로(호스트에 유지)
            - name: fluentbitstate
              mountPath: /var/fluent-bit/state

            # fluent-bit.conf, parsers.conf 마운트(Fluent Bit 기본 설정 경로)
            - name: config
              mountPath: /fluent-bit/etc/
              readOnly: true

            # Lua 스크립트 마운트
            - name: scripts
              mountPath: /fluent-bit/scripts/
              readOnly: true

      volumes:
        - name: varlog
          hostPath:
            # 노드의 컨테이너 로그 경로를 Pod로 주입
            path: /var/log

        - name: fluentbitstate
          hostPath:
            # 오프셋 DB를 노드에 유지하여 재시작 시 중복 전송을 최소화
            path: /var/fluent-bit/state
            type: DirectoryOrCreate

        - name: config
          configMap:
            name: fluent-bit-config
            items:
              # Fluent Bit 메인 설정
              - key: fluent-bit.conf
                path: fluent-bit.conf
              # 파서 설정
              - key: parsers.conf
                path: parsers.conf

        - name: scripts
          configMap:
            name: fluent-bit-config
            items:
              # Lua 스크립트 파일만 별도 경로로 마운트
              - key: stream_name.lua
                path: stream_name.lua
